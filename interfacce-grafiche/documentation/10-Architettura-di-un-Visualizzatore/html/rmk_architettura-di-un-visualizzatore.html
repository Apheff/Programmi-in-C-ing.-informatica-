<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Made with Remarkable!
  </title>
  <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <style type="text/css">
   body,table tr{background-color:#fff}table tr td,table tr th{border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}pre code,table,table tr{padding:0}hr,pre code{background:0 0}body{font:16px Helvetica,Arial,sans-serif;line-height:1.4;color:#333;word-wrap:break-word;padding:10px 15px}strong,table tr th{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{font-weight:700;position:relative;margin-top:15px;margin-bottom:15px;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;overflow:hidden;border:0;border-bottom:1px solid #ddd}a{color:#4183C4}a.absent{color:#c00}ol,ul{padding-left:15px;margin-left:5px}ol{list-style-type:lower-roman}table tr{border-top:1px solid #ccc;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr td :first-child,table tr th :first-child{margin-top:0}table tr td:last-child,table tr th :last-child{margin-bottom:0}img{max-width:100%}blockquote{padding:0 15px;border-left:4px solid #ccc}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;white-space:pre;border:none}.highlight pre,pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}
  </style>
 </head>
 <body>
  <h1 id="architettura-di-un-visualizzatore-per-disegni-in-grafica-vettoriale">
   Architettura di un Visualizzatore per Disegni in Grafica Vettoriale
  </h1>
  <h3 id="descrizione-del-problema">
   Descrizione del problema
  </h3>
  <p>
   Si desidera realizzare un’applicazione desktop finalizzata alla visualizzazione di disegni in grafica vettoriale. L’applicazione deve essere sufficientemente versatile da poter visualizzare disegni generici e non soltanto uno specifico disegno. In particolare, l’architettura deve essere concepita in modo tale da
   <strong>
    separare
   </strong>
   il
   <strong>
    visualizzatore
   </strong>
   dall’oggetto visualizzato, cio&egrave; dal
   <strong>
    disegno
   </strong>
   .
   <br/>
   Tenendo presente che la riproduzione di una qualsiasi informazione grafica deve avvenire mediante la sovrascrizione del metodo
   <em>
    <code>
     paint()
    </code>
   </em>
   della componente swing utilizzata come canvas, una prima possibile architettura che permette di disegnare direttamente all’interno di un
   <strong>
    <code>
     JFrame
    </code>
   </strong>
   &egrave; la seguente:
  </p>
  <p>
   <img alt="arcVis0" src="img/arcVis0.plantUML.svg"/>
   <br/>
   <em>
    Fig. 1: architettura di un visualizzatore per disegni in grafica vettoriale, versione 0.
   </em>
  </p>
  <p>
   Di seguito viene riportata un’implementazione del visualizzatore aderente all’architettura di cui sopra. Per ovvie ragioni di semplicit&agrave; il disegno da visualizzare &egrave; estremamente semplice e consiste in un rettangolo con interno rosso e contorno nero.
  </p>
  <pre><code class="java">import java.awt.Graphics;

public abstract class AbstractDrawing {

    public abstract void draw(Graphics g);

} // end class
</code></pre>
  <pre><code class="java">import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;

public class ConcreteDrawing extends AbstractDrawing {

    private Rectangle2D.Double rect;

    public ConcreteDrawing() {
        this.rect = new Rectangle2D.Double(100, 100, 300, 300); // x, y, width, height
    }

    @Override
    public void draw(Graphics g) {
        Graphics2D g2d = (Graphics2D)g;

        g2d.setColor(Color.red);
        g2d.fill(rect);
        g2d.setColor(Color.black);
        g2d.draw(rect);
    }

} // end class
</code></pre>
  <pre><code class="java">import java.awt.Dimension;
import java.awt.Graphics;
import javax.swing.JFrame;

public class DrawingGUI extends JFrame {

    private AbstractDrawing dw;

    private final static int JFRAME_WIDTH = 800;
    private final static int JFRAME_HEIGHT = 600;

    public DrawingGUI(String title, AbstractDrawing dw) {
        super(title);
        this.dw = dw;
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setPreferredSize(new Dimension(JFRAME_WIDTH, JFRAME_HEIGHT));
        pack();
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        dw.draw(g);
    }

    public static void main(String[] args) {

        final AbstractDrawing drawing = new ConcreteDrawing();

        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new DrawingGUI("Drawing GUI", drawing).setVisible(true);

            }
        }); // end method invokeLater()
    }

} // end class
</code></pre>
  <p>
   &Egrave; semplice osservare che la soluzione appena illustrata presenta i seguenti problemi:
  </p>
  <ul>
   <li>
    non &egrave; possibile visualizzare interamente disegni con dimensioni eccedenti quella della finestra, in altri termini non compaiono le consuete barre di scorrimento orizzontali e/o verticali;
   </li>
   <li>
    nel ridimensionare la finestra il disegno non viene visualizzato in modo stabile.
   </li>
  </ul>
  <p>
   Il secondo problema &egrave; risolvibile utilizzando come canvas il componente
   <strong>
    <code>
     JPanel
    </code>
   </strong>
   , come d’altronde espressamente suggerito dalla documentazione delle Java 2D API. Di seguito viene illustrata la nuova architettura che recepisce tale correzione e a seguire la correzione del codice sorgente.
  </p>
  <p>
   <img alt="arcVis1" src="img/arcVis1.plantUML.svg"/>
   <br/>
   <em>
    Fig. 2: architettura di un visualizzatore per disegni in grafica vettoriale, versione 1.
   </em>
  </p>
  <p>
   Si osservi che in accordo con la documentazione Java (si consulti a tal riguardo la seguente sezione del tutorial
   <a href="https://docs.oracle.com/javase/tutorial/uiswing/painting/index.html">
    Performing Custom Painting
   </a>
   ), anzich&eacute; effettuare l’overriding del metodo
   <code>
    paint()
   </code>
   &egrave; stato sovrascritto il metodo
   <code>
    paintComponent()
   </code>
   di
   <strong>
    <code>
     JPanel
    </code>
   </strong>
   .
  </p>
  <pre><code class="java">import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawingPanel extends JPanel {

    private AbstractDrawing dw = null;

    public void setDrawing(AbstractDrawing dw) {
        this.dw = dw;
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        /* add instructions for your specific drawing */
        dw.draw(g);
    }

} // end class
</code></pre>
  <pre><code class="java">import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Graphics;
import javax.swing.JFrame;

public class DrawingGUI extends JFrame {

    private final static int JFRAME_WIDTH = 800;
    private final static int JFRAME_HEIGHT = 600;

    public DrawingGUI(String title, AbstractDrawing dw) {
        super(title);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setPreferredSize(new Dimension(JFRAME_WIDTH, JFRAME_HEIGHT));

        DrawingPanel drawPanel = new DrawingPanel();
        drawPanel.setDrawing(dw);

        Container contPane = getContentPane();
        contPane.setLayout(new BorderLayout());
        contPane.add(drawPanel, BorderLayout.CENTER);

        pack();
    }

    public static void main(String[] args) {

        final AbstractDrawing drawing = new ConcreteDrawing();

        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new DrawingGUI("Drawing GUI", drawing).setVisible(true);

            }
        }); // end method invokeLater()
    }

} // end class
</code></pre>
  <p>
   Per quanto concerne il primo dei due problemi precedentemente riscontrati, relativo alla mancata visualizzazione delle barre di scorrimento, la soluzione obbligata &egrave; fare uso del componente swing
   <strong>
    <code>
     JScrollPane
    </code>
   </strong>
   che rappresenta appunto la componente che gestisce la visualizzazione delle barre di scorrimento. In particolare, il
   <strong>
    <code>
     JScrollPane
    </code>
   </strong>
   deve essere contenuto in un componente di tipo
   <strong>
    <code>
     Container
    </code>
   </strong>
   (nel nostro caso il
   <strong>
    <code>
     JFrame
    </code>
   </strong>
   ) e contenere a sua volta un altro componente (nel nostro caso il
   <strong>
    <code>
     DrawingPanel
    </code>
   </strong>
   ). Il
   <strong>
    <code>
     JScrollPane
    </code>
   </strong>
   introduce le barre di scorrimento quando il contenuto eccede le dimensioni del contenitore.
   <br/>
   <strong>
    IMPORTANTE
   </strong>
   : il corretto funzionamento del
   <strong>
    <code>
     JScrollPane
    </code>
   </strong>
   &egrave; subordinato al fatto che l’invocazione del metodo
   <code>
    getPreferredSize()
   </code>
   sul componente contenuto restituisca le dimensioni che si desiderano per quel componente. Nel nostro caso, l’invocazione del metodo
   <code>
    getPreferredSize()
   </code>
   sul componente
   <strong>
    <code>
     DrawingPanel
    </code>
   </strong>
   deve restituire delle dimensioni tali da garantire il contenimento del disegno. Pertanto, &egrave; necessario modificare la classe astratta
   <em>
    <code>
     AbstractDrawing
    </code>
   </em>
   aggiungendo i metodi (astratti)
   <em>
    <code>
     getDrawingWidth()
    </code>
   </em>
   e
   <em>
    <code>
     getDrawingHeight()
    </code>
   </em>
   . Di seguito viene illustrata una nuova architettura in cui il dimensionamento del
   <strong>
    <code>
     DrawingPanel
    </code>
   </strong>
   sulla base del disegno contenuto viene svolto dal costruttore della classe
   <strong>
    <code>
     DrawingGUI
    </code>
   </strong>
   . A seguire sono illustrate le modifiche al codice sorgente.
  </p>
  <p>
   <img alt="arcVis2" src="img/arcVis2.plantUML.svg"/>
   <br/>
   <em>
    Fig. 3: architettura di un visualizzatore per disegni in grafica vettoriale, versione 2.
   </em>
  </p>
  <pre><code class="java">import java.awt.Graphics;

public abstract class AbstractDrawing {

    public abstract void draw(Graphics g);

    public abstract int getDrawingWidth();

    public abstract int getDrawingHeight();

} // end class
</code></pre>
  <pre><code class="java">...

public class ConcreteDrawing extends AbstractDrawing {

    private Rectangle2D.Double rect;

    ...

    @Override
    public int getDrawingWidth() {
        return ((int)Math.round(rect.getX() + rect.getWidth() + 0.5));
    }

    @Override
    public int getDrawingHeight() {
        return ((int)Math.round(rect.getY() + rect.getHeight() + 0.5));
    }

} // end class
</code></pre>
  <pre><code class="java">...

public class DrawingGUI extends JFrame {

    private final static int HORIZONTAL_GAP = 10;
    private final static int VERTICAL_GAP = 10;

    ...

    public DrawingGUI(String title, AbstractDrawing dw) {
        ...

        DrawingPanel drawPanel = new DrawingPanel();
        drawPanel.setDrawing(dw);

        drawPanel.setPreferredSize(new Dimension(
                            dw.getDrawingWidth() + HORIZONTAL_GAP,
                            dw.getDrawingHeight() + VERTICAL_GAP));

        JScrollPane scrollPane = new JScrollPane(drawPanel);

        Container contPane = getContentPane();
        contPane.setLayout(new BorderLayout());
        contPane.add(scrollPane, BorderLayout.CENTER);

        pack();
    }

    ...

} // end class
</code></pre>
  <p>
   Sebbene la soluzione appena illustrata sia efficace, la logica che segue &egrave; in conflitto con quella seguita dal metodo
   <code>
    pack()
   </code>
   in cui &egrave; previsto che ogni componente sia in grado di determinare le proprie dimensioni sulla base delle componenti contenute (approccio bottom-up). In altri termini, sarebbe meglio che il
   <strong>
    <code>
     DrawingPanel
    </code>
   </strong>
   sia in grado di stabilire le proprie dimensioni in modo autonomo sulla base del disegno contenuto. Di seguito viene proposta una nuova architettura e le conseguenti modifiche al codice sorgente.
  </p>
  <p>
   <img alt="arcVis3" src="img/arcVis3.plantUML.svg"/>
   <br/>
   <em>
    Fig. 4: architettura di un visualizzatore per disegni in grafica vettoriale, versione 3.
   </em>
  </p>
  <pre><code class="java">import java.awt.Dimension;
import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawingPanel extends JPanel {

    private final static int HORIZONTAL_GAP = 10;
    private final static int VERTICAL_GAP = 10;

    private AbstractDrawing dw = null;

    public DrawingPanel(AbstractDrawing dw) {
        super();
        this.dw = dw;
        updatePanelPreferredSize();
    }

    public void setDrawing(AbstractDrawing dw) {
        this.dw = dw;
        updatePanelPreferredSize();
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        /* add instructions for your specific drawing */
        dw.draw(g);
    }

    private void updatePanelPreferredSize() {
        setPreferredSize(new Dimension(
                        dw.getDrawingWidth() + HORIZONTAL_GAP,
                        dw.getDrawingHeight() + VERTICAL_GAP));
    }

} // end class
</code></pre>
  <pre><code class="java">...

public class DrawingGUI extends JFrame {

    private final static int JFRAME_WIDTH = 800;
    private final static int JFRAME_HEIGHT = 600;

    public DrawingGUI(String title, AbstractDrawing dw) {
        super(title);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setPreferredSize(new Dimension(JFRAME_WIDTH, JFRAME_HEIGHT));

        DrawingPanel drawPanel = new DrawingPanel(dw);

        JScrollPane scrollPane = new JScrollPane(drawPanel);

        Container contPane = getContentPane();
        contPane.setLayout(new BorderLayout());
        contPane.add(scrollPane, BorderLayout.CENTER);

        pack();
    }

    public static void main(String[] args) {

        ...
    }

} // end class
</code></pre>
  <p>
   La soluzione appena proposta pu&ograve; esser resa ancor pi&ugrave; efficace ed elegante tenendo presente che, in base a quanto riportato nella documentazione del framework Swing, il funzionamento del metodo
   <code>
    pack()
   </code>
   prevede l’invocazione del metodo
   <code>
    getPreferredSize()
   </code>
   per chiedere ad un dato componente di fornirgli la sua dimensione “preferita”. Pertanto, una soluzione elegante e che si inserisce pienamente in questa logica consiste nell’effettuare l’overriding del metodo
   <code>
    getPreferredSize()
   </code>
   nella classe
   <strong>
    <code>
     DrawingPanel
    </code>
   </strong>
   , restituendo una dimensione tale da garantire il contenimento del disegno. Di seguito sono illustrate le modifiche all’architettura e al codice sorgente.
  </p>
  <p>
   <img alt="arcVis4" src="img/arcVis4.plantUML.svg"/>
   <br/>
   <em>
    Fig. 5: architettura di un visualizzatore per disegni in grafica vettoriale, versione 4.
   </em>
  </p>
  <pre><code class="java">...

public class DrawingPanel extends JPanel {

    ...

    public DrawingPanel(AbstractDrawing dw) {
        super();
        this.dw = dw;
    }

    public void setDrawing(AbstractDrawing dw) {
        this.dw = dw;
    }

    ...

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(
                dw.getDrawingWidth() + HORIZONTAL_GAP,
                dw.getDrawingHeight() + VERTICAL_GAP);
    }

} // end class
</code></pre>
  <p>
   Si supponga ora di voler dotare il visualizzatore di un’ulteriore funzionalit&agrave;, estremamente comune negli editor di grafica vettoriale, quale la possibilit&agrave; di modificare il fattore di scale del disegno. In altri termini, le primitive geometriche che descrivono il disegno devono essere espresse in forma parametrica rispetto al fattore di scala. Inoltre, ogni volta che viene richiesto il cambiamento di scala &egrave; necessario assicurarsi che le coordinate di tutti gli oggetti costituenti il disegno siano effettivamente aggiornate in modo coerente al cambiamento di scala.
   <br/>
   Si noti che uno dei rischi che &egrave; possibile introdurre adottando soluzioni estemporanee &egrave; che, a causa di errori di arrotondamento, non sia sempre possibile riottenere il disegno “originale”. Ad esempio, applicando in cascata i seguenti cambiamenti di scala:
   <em>
    x 1/3
   </em>
   ,
   <em>
    x 1/3
   </em>
   ,
   <em>
    x 1/3
   </em>
   ,
   <em>
    x 3
   </em>
   ,
   <em>
    x 3
   </em>
   ,
   <em>
    x 3
   </em>
   il disegno finale potrebbe in realt&agrave; avere delle coordinate diverse da quello iniziale.
   <br/>
   Di seguito viene illustrata una nuova architettura del visualizzatore che implementa anche questa funzionalit&agrave; e che aggira il problema appena discusso limitando i possibili valori dei fattori di scala ai seguenti: {
   <em>
    0.01
   </em>
   ,
   <em>
    0.025
   </em>
   ,
   <em>
    0.05
   </em>
   ,
   <em>
    0.10
   </em>
   ,
   <em>
    0.25
   </em>
   ,
   <em>
    0.50
   </em>
   ,
   <em>
    0.75
   </em>
   ,
   <em>
    1.00
   </em>
   ,
   <em>
    1.25
   </em>
   ,
   <em>
    1.50
   </em>
   ,
   <em>
    1.75
   </em>
   ,
   <em>
    2.00
   </em>
   ,
   <em>
    4.00
   </em>
   ,
   <em>
    8.00
   </em>
   ,
   <em>
    16.00
   </em>
   ,
   <em>
    24.00
   </em>
   ,
   <em>
    32.00
   </em>
   ,
   <em>
    64.00
   </em>
   }.
   <br/>
   In particolare, utilizzando due appositi pulsanti della GUI, l’utente pu&ograve; aumentare o ridurre il fattore di scala a patto di rimanere all’interno del set di valori prestabiliti.
  </p>
  <p>
   <img alt="arcVis5" src="img/arcVis5.plantUML.svg"/>
   <br/>
   <em>
    Fig. 6: architettura di un visualizzatore per disegni in grafica vettoriale, versione 6; il visualizzatore permette di modificare il fattore di scala dei disegni.
   </em>
  </p>
  <pre><code class="java">import java.awt.Graphics;

public abstract class AbstractDrawing {

    protected double scaleFactor = 1.0;
    protected double previousScaleFactor = 1.0;

    public void setScaleFactor(double scaleFactor) {
        this.previousScaleFactor = this.scaleFactor;
        this.scaleFactor = scaleFactor;
        this.rescaleDrawing();
    }

    public abstract void draw(Graphics g);

    public abstract int getDrawingWidth();

    public abstract int getDrawingHeight();

    protected abstract void rescaleDrawing();

} // end class
</code></pre>
  <pre><code class="java">...

public class ConcreteDrawing extends AbstractDrawing {

    private Rectangle2D.Double rect;

    ...

    @Override
    protected void rescaleDrawing() {
        this.rect.setRect(
                this.rect.getX() * this.scaleFactor / this.previousScaleFactor,
                this.rect.getY() * this.scaleFactor / this.previousScaleFactor,
                this.rect.getWidth() * this.scaleFactor / this.previousScaleFactor,
                this.rect.getHeight() * this.scaleFactor / this.previousScaleFactor);
    }

} // end class
</code></pre>
  <pre><code class="java">...

public class DrawingPanel extends JPanel {

    ...

    public void setScaleFactor(double scaleFactor) {
        dw.setScaleFactor(scaleFactor);
    }

} // end class
</code></pre>
  <pre><code class="java">...
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JToolBar;

public class DrawingGUI extends JFrame implements ActionListener {

    ...
    private final static String ZOOM_IN = "zoom in";
    private final static String ZOOM_OUT = "zoom out";
    private final static double[] SCALE_FACTOR_ARRAY = {0.01, 0.025, 0.05, 0.10, 0.25, 0.50, 0.75,
                            1.00, 1.25, 1.50, 1.75, 2.00, 4.00, 8.00,
                            16.00, 24.00, 32.00, 64.00};
    private final static int DEFAULT_SCALE_INDEX = 7;

    private int scaleIndex;
    private DrawingPanel drawPanel;

    public DrawingGUI(String title, AbstractDrawing dw) {
        super(title);
        this.scaleIndex = DEFAULT_SCALE_INDEX;

        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setPreferredSize(new Dimension(JFRAME_WIDTH, JFRAME_HEIGHT));

        // Create the toolbar.
        JToolBar toolBar = new JToolBar("Still draggable");
        addButtons(toolBar);

        this.drawPanel = new DrawingPanel(dw);

        JScrollPane scrollPane = new JScrollPane(drawPanel);

        Container contPane = getContentPane();
        contPane.setLayout(new BorderLayout());
        contPane.add(scrollPane, BorderLayout.CENTER);

        contPane.add(toolBar, BorderLayout.PAGE_START);

        pack();
    }

    private void addButtons(JToolBar toolBar) {
        // Insert the "zoom in" button.
        JButton zoomIn = new JButton(ZOOM_IN);
        zoomIn.addActionListener(this);
        zoomIn.setActionCommand(ZOOM_IN);
        toolBar.add(zoomIn);

        // Insert the "zoom out" button.
        JButton zoomOut = new JButton(ZOOM_OUT);
        zoomOut.addActionListener(this);
        zoomOut.setActionCommand(ZOOM_OUT);
        toolBar.add(zoomOut);
    }

    private void zoomIn() {
        if ((this.scaleIndex + 1) &lt; SCALE_FACTOR_ARRAY.length) {
            this.scaleIndex++;
            this.drawPanel.setScaleFactor(SCALE_FACTOR_ARRAY[this.scaleIndex]);
        }
    }

    private void zoomOut() {
        if ((this.scaleIndex - 1) &gt; 0) {
            this.scaleIndex--;
            this.drawPanel.setScaleFactor(SCALE_FACTOR_ARRAY[this.scaleIndex]);
        }
    }

    public void actionPerformed(ActionEvent e) {
        String cmd = e.getActionCommand();

        // Handle each button.
        if (ZOOM_IN.equals(cmd)) { // "zoom in" button clicked
            zoomIn();
            System.out.println("Pressed button: " + ZOOM_IN + " - scaleFactor = " + SCALE_FACTOR_ARRAY[this.scaleIndex]);
            drawPanel.revalidate();
            drawPanel.repaint();
        }
        else if (ZOOM_OUT.equals(cmd)) { // "zoom out" button clicked
            zoomOut();
            System.out.println("Pressed button: " + ZOOM_OUT + " - scaleFactor = " + SCALE_FACTOR_ARRAY[this.scaleIndex]);
            drawPanel.revalidate();
            drawPanel.repaint();
        }
    }

    public static void main(String[] args) {

        final AbstractDrawing drawing = new ConcreteDrawing();

        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new DrawingGUI("Drawing GUI", drawing).setVisible(true);

            }
        }); // end method invokeLater()
    }

} // end class
</code></pre>
  <p>
   Un’altra possibilit&agrave; per evitare il problema delle approssimazioni consiste nel mantenere due descrizioni del disegno, una indipendente dal fattore di scala (o corrispondente al fattore di scala
   <em>
    sf = 1.0
   </em>
   ) e l’altra dipendente dal fattore di scala che utilizza la prima come riferimento. Di seguito viene illustrata una possibile architettura specificatamente pensata per tale approccio e le modifiche da apportare al codice sorgente.
  </p>
  <p>
   <img alt="arcVis6" src="img/arcVis6.plantUML.svg"/>
   <br/>
   <em>
    Fig. 7: architettura di un visualizzatore per disegni in grafica vettoriale, versione 7; il visualizzatore permette di modificare il fattore di scala dei disegni.
   </em>
  </p>
  <pre><code class="java">import java.awt.Graphics;

public abstract class AbstractDrawing {

    protected double scaleFactor = 1.0;

    public void setScaleFactor(double scaleFactor) {
        this.scaleFactor = scaleFactor;
        this.rescaleDrawing();
    }

    public abstract void draw(Graphics g);

    public abstract int getDrawingWidth();

    public abstract int getDrawingHeight();

    protected abstract void rescaleDrawing();

} // end class
</code></pre>
  <pre><code class="java">...

public class ConcreteDrawing extends AbstractDrawing {

    private Rectangle2D.Double unscaledRect;
    private Rectangle2D.Double rect;

    public ConcreteDrawing() {
        this.unscaledRect = new Rectangle2D.Double(100, 100, 300, 300); // x, y, width, height
        this.rect = new Rectangle2D.Double(
                        this.unscaledRect.getX() * this.scaleFactor,
                        this.unscaledRect.getY() * this.scaleFactor,
                        this.unscaledRect.getWidth() * this.scaleFactor,
                        this.unscaledRect.getHeight() * this.scaleFactor);
    }

    ...

    @Override
    protected void rescaleDrawing() {
        this.rect.setRect(
                this.unscaledRect.getX() * this.scaleFactor,
                this.unscaledRect.getY() * this.scaleFactor,
                this.unscaledRect.getWidth() * this.scaleFactor,
                this.unscaledRect.getHeight() * this.scaleFactor);
    }

} // end class
</code></pre>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>
