<!DOCTYPE html>
<!--<html lang="en">-->
<html lang="it">
<head>
	<!--<meta charset="utf-8">-->
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="description" content="Esercitazione di Elementi di Informatica Grafica - Dipartimento d'Ingegneria - Universit&agrave; degli Studi di Perugia">
	<meta name="author" content="Luca Grilli">
	
	<title>Esercitazione di Elementi di Informatica Grafica</title>
	<style>
		#preview-box {
			background-color: rgba(1,1,1,0.1);
			padding: 1px 10px;
			border-radius: 10px;
		}
	</style>
	<link id="linkstyle" rel="stylesheet" href="css/markdown.css">
</head>

<body>

<!-- [start] SELETTORE STILE
================================================== -->
<strong>Scegli un altro foglio di stile</strong>
<div id="preview-box">
		<select style="width:100%" id="themes">
			<option value="css/markdown.css">markdown</option>
			<option value="css/markdown-alt.css">markdown-alt</option>
			<option value="css/markdown-luca.css">markdown-luca</option>
			<option value="css/markdown1.css">markdown1</option>
			<option value="css/markdown2.css">markdown2</option>
			<option value="css/markdown3.css">markdown3</option>
			<option value="css/markdown4.css">markdown4</option>
			<option value="css/markdown5.css">markdown5</option>
			<option value="css/markdown6.css">markdown6</option>
			<option value="css/markdown7.css">markdown7</option>
			<option value="css/markdown8.css">markdown8</option>
			<option value="css/markdown9.css">markdown9</option>
			<option value="css/markdown10.css">markdown10</option>
			<option value="css/avenir-white.css">avenir-white</option>
			<option value="css/foghorn.css">foghorn</option>
			<option value="css/screen.css">screen</option>
			<option value="css/swiss.css">swiss</option>
			<option value="css/pandoc-default.css">pandoc-default</option>
			<option value="css/pandoc-bigger-font-code.css">pandoc-bigger-font-code</option>
			<option value="css/splendor.css">splendor</option>
		</select>
</div>
<script>
	var linkstyle = document.getElementById('linkstyle');
	var themes = document.getElementById('themes');
	themes.onchange = function(e) {
		linkstyle.href = themes.value;
	};
</script>
<!-- [end] SELETTORE STILE
================================================== -->

<!-- [start] PANDOC OUTPUT
================================================== -->


<h1 id="gestione-degli-stream-di-caratteri-in-java">Gestione degli Stream di Caratteri in Java</h1>
<h3 id="stream-di-caratteri">Stream di Caratteri</h3>
<p>Uno <strong>stream di caratteri</strong> permette di spedire o ricevere caratteri sotto forma di sequenza ordinata di byte. Java fornisce un ampio insieme di classi per gestire stream di caratteri.</p>
<p>Un <strong>carattere</strong> (tipo <strong>char</strong>) in Java &egrave; codificato su 16 bit, ma quando si ha la necessit&agrave; di inviare una sequenza di caratteri (ad esempio una stringa, un file di testo, ecc.) &egrave; possibile specificare il tipo di codifica e decodifica associata alla sequenza di caratteri dello stream. Esistono molti standard diversi per la codifica di insiemi di caratteri in sequenze ordinate di byte; le pi&ugrave; comuni sono:</p>
<ul>
<li>ASCII 7 bit;</li>
<li>ASCII 8 bit (ISO Latin 1);</li>
<li>Unicode;</li>
<li>UTF-8.</li>
</ul>
<h3 id="classi-astratte-reader-e-writer">Classi astratte <em><code>Reader</code></em> e <em><code>Writer</code></em></h3>
<p>In Java, le classi base per la gestione di stream di caratteri sono:</p>
<ul>
<li><em><code>Reader</code></em>: &egrave; la superclasse di tutti gli input stream di caratteri e svolge un ruolo simile a quello di <em><code>InputStream</code></em> per gli stream di byte.</li>
<li><em><code>Writer</code></em>: &egrave; la superclasse di tutti gli output stream di caratteri e svolge un ruolo simile a quello di <em><code>OutputStream</code></em> per gli stream di byte;</li>
</ul>
<p>Trattandosi di classi astratte non &egrave; possibile utilizzare pubblicamente i costruttori di <em><code>Reader</code></em> e di <em><code>Writer</code></em>, i quali sono dichiarati <code>protected</code>, cio&egrave; utilizzabili solo dalle loro sottoclassi.</p>
<div class="figure">
<img src="img/ReaderWriter.svg" alt="Reader/Writer in Java" />
<p class="caption">Reader/Writer in Java</p>
</div>
<p><em>Fig 1: Classi astratte <code>Reader</code> e <code>Writer</code> di Java.</em></p>
<h3 id="stream-di-caratteri-che-usano-stream-di-byte">Stream di caratteri che usano stream di byte</h3>
<h4 id="classi-inputstreamreader-e-outputstreamreader">Classi <strong><code>InputStreamReader</code></strong> e <strong><code>OutputStreamReader</code></strong></h4>
<p>La classe <strong><code>InputStreamReader</code></strong> rappresenta un ponte tra un <em><code>Reader</code></em> ed un input stream di byte; essa mette a disposizione dei meccanismi di decodifica di sequenze di byte in caratteri. In altri termi un <strong><code>InputStreamReader</code></strong> legge dei byte, presenti nello stream di input, e li decodifica in caratteri usando un &quot;charset&quot; predefinito. In particolare, il &quot;charset&quot; utilizzato pu&ograve; essere specificato in modo esplicito (specificando un oggetto <em><code>Charset</code></em> o specificando un nome) o pu&ograve; utilizzarsi il charset di default della piattaforma. Per una maggior efficienza della conversione di byte in caratteri, conviene leggere in anticipo pi&ugrave; byte di quelli strettamente necessari. Per ottimizzare l'efficienza si consiglia pertanto di incapsulare un <strong><code>InputStreamReader</code></strong> in un <strong><code>BufferedReader</code></strong>. Si noti che la classe <strong><code>InputStreamReader</code></strong> eredita dalla classe astratta <em><code>Reader</code></em>.</p>
<p>La classe <strong><code>OutputStreamWriter</code></strong> rappresenta un ponte tra un <em><code>Writer</code></em> ed un output stream di byte; essa mette pertanto a disposizione dei meccanismi di codifica di caratteri in sequenze di byte. In altri termi un <strong><code>OutputStreamWriter</code></strong> riceve dei caratteri, da inviare nello stream di output, e li codifica in byte usando un &quot;charset&quot; predefinito. In particolare, il &quot;charset&quot; utilizzato pu&ograve; essere specificato in modo esplicito (specificando un oggetto di tipo <em><code>Charset</code></em> o specificando un nome) o pu&ograve; utilizzarsi il charset di default della piattaforma. Un <strong><code>OutputStreamWriter</code></strong> &egrave; dotato di un buffer in cui vengono accumulati i byte ottenuti mano a mano che i caratteri vengono codificati. La dimensione di questo buffer pu&ograve; essere specificata, ma di default &egrave; sufficientemente capiente per molti scopi. Per ottimizzare l'efficienza, si consiglia tuttavia di incapsulare un <strong><code>OutputStreamWriter</code></strong> in un <strong><code>BufferedWriter</code></strong>. Si noti che la classe <strong><code>OutputStreamWriter</code></strong> eredita dalla classe <em><code>Writer</code></em>.</p>
<div class="figure">
<img src="img/InputStreamReaderOutputStreamWriter.svg" alt="InputStreamReader/OutputStreamWriter in Java" />
<p class="caption">InputStreamReader/OutputStreamWriter in Java</p>
</div>
<p><em>Fig 2: Classi</em> <strong><code>InputStreamReader</code></strong> <em>e</em> <strong><code>OutputStreamWriter</code></strong> <em>di Java.</em></p>
<h3 id="esempio-uno-scrittore-di-file">Esempio: uno scrittore di file</h3>
<p>Vogliamo realizzare una semplice applicazione di nome <strong><code>FileEncode</code></strong> che prende sulla linea di comando i seguenti parametri: <em><code>FileEncode &lt;file-name&gt; &lt;encode&gt; [string1] [string2] ...</code></em> e che crea un file di nome <em>file-name</em> in cui vengono scritte le stringhe <em>string1, string2, ..., stringk</em> su linee diverse nella codifica <em>encode</em>. Una possibile implementazione di <strong><code>FileEncode</code></strong> &egrave; la seguente.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.io.FileOutputStream;</span>
<span class="kw">import java.io.IOException;</span>
<span class="kw">import java.io.OutputStreamWriter;</span>

<span class="kw">public</span> <span class="kw">class</span> FileEncode {

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) <span class="kw">throws</span> IOException {

        <span class="kw">if</span> (args.<span class="fu">length</span> &lt; <span class="dv">2</span>)
            <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(<span class="st">&quot;Usage: FileEncode &lt;file-name&gt; &lt;charset&gt; [string]&quot;</span>);

        <span class="co">// crea un output stream verso un file</span>
        FileOutputStream fout = <span class="kw">new</span> FileOutputStream(args[<span class="dv">0</span>]);
        OutputStreamWriter foutWriter = <span class="kw">new</span> OutputStreamWriter(fout, args[<span class="dv">1</span>]);

        <span class="co">// scrive le stringhe nel file</span>
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt; args.<span class="fu">length</span>; i++)
            foutWriter.<span class="fu">write</span>(args[i] + <span class="st">&quot;</span><span class="ch">\r\n</span><span class="st">&quot;</span>);

        <span class="co">// chiude gli stream</span>
        foutWriter.<span class="fu">close</span>();
        fout.<span class="fu">close</span>();
    }
} <span class="co">// end class</span></code></pre></div>
<h1 id="gestione-di-file-testuali-in-java">Gestione di File Testuali in Java</h1>
<h3 id="lettura-di-file-riga-per-riga">Lettura di file riga per riga</h3>
<p>Quasi sempre nella applicazioni &egrave; necessario leggere e/o salvare delle informazioni su file; si pensi ad esempio ai parametri di configurazione di un'applicazione, salvandoli su file possono essere modificati senza dover effettuare la ricompilazione del codice sorgente. Nella scelta della codifica di salvataggio spesso si opta per codifiche di tipo testuale in cui il file viene organizzato in righe; una riga &egrave; una qualsiasi stringa di caratteri che termina con un carattere/stringa speciale di ritorno a capo, ad esempio <code>\n</code> (<em>new line</em> o <em>line feed</em>) oppure <code>\r\n</code> (<em>carriage return</em> e <em>line feed</em>). La scelta di suddividere il file in righe separate agevola la successiva lettura del file; si tratta di una forma primordiale di strutturazione del file. Ogni riga rappresenta una unit&agrave; informativa del tutto o parzialmente indipendente dalle altre e pu&ograve; essere elaborata in modo separato. Un esempio tipico &egrave; il formato <em>CSV</em> (<em>Comma Separated Values</em>).</p>
<p><strong>Esercizio 1</strong>: nello sviluppo di un videogame si desiderano mantenere su file le seguenti informazioni: <em>nome, cognome, punteggio</em>. Tali informazioni devono essere lette all'avvio e aggiornate in chiusura. Come conviene procedere?</p>
<p><strong>Soluzione Esercizio 1</strong>. Per prima cosa &egrave; necessario stabilire un formato di salvataggio che sia adeguato e al tempo stesso semplice da gestire. Optando per un formato testuale di tipo CSV, si pu&ograve; stabilire che ogni riga fa riferimento ad un singolo giocatore ed &egrave; costituita da tre elementi (detti anche &quot;token&quot;) separati dal carattere ';' (o un qualsiasi altro carattere di separazione che non dovr&agrave; comparire nei token). Un esempio di un possibile file CSV &egrave; il seguente:</p>
<pre class="csv"><code>...
mario;rossi;23750
walter;bianchi;154865
giuseppe;verdi;7800
...
...
...
carlo;neri;125600
...</code></pre>
<p>In seconda istanza sar&agrave; necessario stabilire in quale struttura dati memorizzare tali informazioni, detta struttura dati dovr&agrave; essere popolata subito dopo l'avvio del programma. Si evince pertanto che &egrave; necessario disporre di:</p>
<ol style="list-style-type: lower-alpha">
<li><p>funzionalit&agrave; per la lettura di file CSV nel formato sopra definito;</p></li>
<li><p>una struttura dati su cui mantenere le informazioni presenti nel file;</p></li>
<li><p>funzionalit&agrave; per la scrittura/aggiornamento di file CSV.</p></li>
</ol>
<p>Di seguito viene proposta una possibile soluzione dell'Esercizio 1 ottenuta scomponendolo in tre sotto-problemi separati, corrispondenti agli Esercizi 1a, 1b e 1c.</p>
<p><strong>Esercizio 1a</strong>: scrivere il codice di una classe <strong><code>ReadCSV</code></strong> avente un metodo statico con il seguente prototipo <code>public static LinkedList&lt;String[]&gt; getRows(String fileName, String charset) throws FileNotFoundEXception, IOException</code> in cui la riga i-esima del file corrisponde all'i-esimo array della lista e il j-esimo token corrisponde alla j-esima componente dell'array.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.util.LinkedList;</span>
<span class="kw">import java.io.BufferedReader;</span>
<span class="kw">import java.io.InputStreamReader;</span>
<span class="kw">import java.io.FileInputStream;</span>
<span class="kw">import java.io.FileNotFoundException;</span>
<span class="kw">import java.io.IOException;</span>

<span class="kw">public</span> <span class="kw">class</span> ReadCSV {

    <span class="kw">public</span> <span class="dt">static</span> LinkedList&lt;String[]&gt; <span class="fu">getRows</span>(String fileName, String charset) <span class="kw">throws</span> FileNotFoundException, IOException {
        LinkedList&lt;String[]&gt; lstRows = <span class="kw">null</span>;

        <span class="co">//to-do</span>

        <span class="kw">return</span> lstRows;
    }
} <span class="co">// end class</span></code></pre></div>
<p><strong>Esercizio 1b</strong>: scrivere il codice di una possibile struttura dati, di nome <strong><code>PlayerData</code></strong>, che permetta di memorizzare le informazioni presenti nel file CSV.</p>
<p><strong>Suggerimento</strong>: usare una lista di oggetti <strong><code>Player</code></strong> caratterizzati ciascuno da un <em>nome</em>, da un <em>cognome</em> e da un punteggio.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Player {

    <span class="co">//to-do</span>

} <span class="co">// end class</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.util.LinkedList;</span>

<span class="kw">public</span> <span class="kw">class</span> PlayerData {

    <span class="kw">private</span> LinkedList&lt;Player&gt; playerLst;

    <span class="co">//to-do</span>

} <span class="co">// end class</span></code></pre></div>
<p><strong>Esercizio 1c</strong>: scrivere il codice di una classe <strong><code>WriteCSV</code></strong> con un metodo <code>write()</code> che sia speculare al metodo <code>read()</code> di <strong><code>ReadCSV</code></strong>. Se ritenuto opportuno, modificare anche la classe <strong><code>PlayerData</code></strong>.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.io.BufferedWriter;</span>
<span class="kw">import java.io.FileOutputStream;</span>
<span class="kw">import java.io.IOException;</span>
<span class="kw">import java.io.OutputStreamWriter;</span>
<span class="kw">import java.io.PrintWriter;</span>

<span class="kw">import java.util.LinkedList;</span>

<span class="kw">public</span> <span class="kw">class</span> WriteCSV {

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">print</span>(String fileName, String charset, LinkedList&lt;String[]&gt; lstSA) <span class="kw">throws</span> IOException {


        <span class="co">//to-do</span>


    }
} <span class="co">// end class</span></code></pre></div>
<p>Implementare una classe di test che permetta di leggere i dati da un file di input <em>data.csv</em>, di popolare la struttura dati <strong><code>PlayerData</code></strong> e di salvare successivamente il contenuto di quest'ultima nel file <em>data2.csv</em>. Un'implementazione corretta dovrebbe implicare l'identit&agrave; dei file <em>data.csv</em> e <em>data2.csv</em>.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.util.LinkedList;</span>

<span class="kw">public</span> <span class="kw">class</span> Test {

        <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) <span class="kw">throws</span> Exception {

            <span class="co">//to-do</span>

        } <span class="co">// end method main()</span>
} <span class="co">// end class</span></code></pre></div>
<p><strong>IMPORTANTE</strong>: con l'avvento di Java 7 sono state introdotte delle funzionalit&agrave; aggiuntive che semplificano notevolmente le comuni operazioni di lettura e scrittura da e su file, e le rendono generalmente molto pi&ugrave; efficienti. A tal riguardo si consulti la documentazione Java relativamente al package <code>java.nio</code> (<em>nio</em> &egrave; l'acronimo di <em>Non-blocking I/O</em>) e in particolare i seguenti argomenti:</p>
<ul>
<li>File I/O (Featuring NIO.2) <a href="http://docs.oracle.com/javase/tutorial/essential/io/fileio.html" title="File I/O (Featuring NIO.2)">[Tutorial]</a></li>
<li><code>java.nio.file.</code><strong><code>Files</code></strong> <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html" title="java.nio.file.Files">[API]</a></li>
</ul>
<p>Come utile esercizio provare a semplificare i precedenti programmi utilizzando le funzionalit&agrave; della classe <code>java.nio.file.</code><strong><code>Files</code></strong>.</p>

<!-- [end] PANDOC OUTPUT
================================================== -->

</body>
</html>
