<!DOCTYPE html>
<!--<html lang="en">-->
<html lang="it">
<head>
	<!--<meta charset="utf-8">-->
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="description" content="Esercitazione di Elementi di Informatica Grafica - Dipartimento d'Ingegneria - Universit&agrave; degli Studi di Perugia">
	<meta name="author" content="Luca Grilli">
	
	<title>Esercitazione di Elementi di Informatica Grafica</title>
	<style>
		#preview-box {
			background-color: rgba(1,1,1,0.1);
			padding: 1px 10px;
			border-radius: 10px;
		}
	</style>
	<link id="linkstyle" rel="stylesheet" href="css/markdown.css">
</head>

<body>

<!-- [start] SELETTORE STILE
================================================== -->
<strong>Scegli un altro foglio di stile</strong>
<div id="preview-box">
		<select style="width:100%" id="themes">
			<option value="css/markdown.css">markdown</option>
			<option value="css/markdown-alt.css">markdown-alt</option>
			<option value="css/markdown-luca.css">markdown-luca</option>
			<option value="css/markdown1.css">markdown1</option>
			<option value="css/markdown2.css">markdown2</option>
			<option value="css/markdown3.css">markdown3</option>
			<option value="css/markdown4.css">markdown4</option>
			<option value="css/markdown5.css">markdown5</option>
			<option value="css/markdown6.css">markdown6</option>
			<option value="css/markdown7.css">markdown7</option>
			<option value="css/markdown8.css">markdown8</option>
			<option value="css/markdown9.css">markdown9</option>
			<option value="css/markdown10.css">markdown10</option>
			<option value="css/avenir-white.css">avenir-white</option>
			<option value="css/foghorn.css">foghorn</option>
			<option value="css/screen.css">screen</option>
			<option value="css/swiss.css">swiss</option>
			<option value="css/pandoc-default.css">pandoc-default</option>
			<option value="css/pandoc-bigger-font-code.css">pandoc-bigger-font-code</option>
			<option value="css/splendor.css">splendor</option>
		</select>
</div>
<script>
	var linkstyle = document.getElementById('linkstyle');
	var themes = document.getElementById('themes');
	themes.onchange = function(e) {
		linkstyle.href = themes.value;
	};
</script>
<!-- [end] SELETTORE STILE
================================================== -->

<!-- [start] PANDOC OUTPUT
================================================== -->


<h1 id="una-prima-gui-interattiva">Una Prima GUI Interattiva</h1>
<h3 id="la-classe-swingapplication">La classe SwingApplication</h3>
<h5 id="esercizio-1">Esercizio 1</h5>
<p>Si desidera realizzare un'applicazione grafica nella tecnologia JFC/Swing che visualizzi, in una finestra grafica, un pulsante e un'etichetta in cui viene riportato il numero di click dell'utente sul pulsante.</p>
<p><img src="img/SwingApplicationGUIa.png" alt="javax.swing.JButton" /> <em>Fig 1.a: GUI iniziale</em></p>
<p><img src="img/SwingApplicationGUIb.png" alt="javax.swing.JButton" /> <em>Fig 1.b: GUI dopo sette click</em></p>
<p>Si richiede di implementare la GUI mediante un'unica classe Java, di nome <strong><code>SwingApplication</code></strong>, contenente il metodo <code>main()</code> necessario ad avviare l'applicazione grafica.</p>
<h5 id="soluzione-esercizio-1">Soluzione Esercizio 1</h5>
<p>Proviamo a progettare la GUI di <strong><code>SwingApplication</code></strong> procedendo per gradi, separando la definizione del layout dalla gestione dell'interazione con l'utente. In particolare, nella Fase 1 svilupperemo una GUI che presenta il layout desiderato, ma che non &egrave; interattiva (non risponde agli input dell'utente) e nella Fase 2 provvederemo a rendere la GUI interattiva secondo quanto specificato nel testo dell'esercizio.</p>
<h5 id="fase-1-gui-non-interattiva">Fase 1: GUI non interattiva</h5>
<p>Definire il layout della GUI significa specificare in modo appropriato:</p>
<ol style="list-style-type: decimal">
<li>le componenti grafiche utilizzate e la relativa gerarchia d'inclusione (alcune componenti Swing, componenti di tipo <strong><code>Container</code></strong>, fungono da contenitori e possono contenere a loro volta altre componenti <strong><code>Container</code></strong> che includono ulteriori gruppi di componenti e cos&igrave; via);</li>
<li>l'organizzazione spaziale delle componenti, pi&ugrave; specificatamente, per ogni componente di tipo <strong><code>Container</code></strong> &egrave; necessario specificare la disposizione spaziale delle componenti che contiene.</li>
</ol>
<h6 id="fase-1.1-gerarchia-dinclusione-delle-componenti">Fase 1.1: Gerarchia d'inclusione delle componenti</h6>
<p>Componenti Swing della GUI:</p>
<ul>
<li><code>javax.swing.</code><strong><code>JFrame</code></strong>: finestra principale della GUI e root della gerarchia di inclusione;</li>
<li><code>java.awt.</code><strong><code>Container</code></strong>: content pane del <strong><code>JFrame</code></strong>;</li>
<li><code>javax.swing.</code><strong><code>JPanel</code></strong>: pannello contenente il pulsante e l'etichetta;</li>
<li><code>javax.swing.</code><strong><code>JButton</code></strong>: pulsante della GUI;</li>
<li><code>javax.swing.</code><strong><code>JLabel</code></strong>: etichetta della GUI.</li>
</ul>
<div class="figure">
<img src="img/drawingFont18.svg" alt="Gerarchia inclusione componenti" />
<p class="caption">Gerarchia inclusione componenti</p>
</div>
<p><em>Fig 2: Gerarchia di inclusione delle componenti Swing della GUI</em></p>
<p>La gerarchia d'inclusione delle componenti prevede la presenza di due componenti di tipo <code>Container</code>: il <em>content pane</em> del <strong><code>JFrame</code></strong> e il <strong><code>JPanel</code></strong>. I gestori di layout utilizzabili per ottenere una GUI analoga a quella visualizzata in Fig. 1 sono:</p>
<ul>
<li>il <code>java.awt.</code><strong><code>BorderLayout</code></strong>: &egrave; il gestore di layout di default del content pane di un <strong><code>JFrame</code></strong>, nel nostro caso sar&agrave; necessario specificare l'opzione <em>CENTER</em>;</li>
<li>il <code>java.awt.</code><strong><code>GridLayout</code></strong>: &egrave; il gestore di layout che assegneremo al <strong><code>JPanel</code></strong>; permette di arrangiare le componenti secondo uno schema a matrice di cui vengono specificate le righe e colonne (&egrave; consentito anche lasciare indefinita una delle due dimensioni della matrice); nel nostro caso considereremo una matrice 2 x 1 oppure una matrice N x 1, ove N arbitrario va specificato con zero (0 x 1 sta per N x 1 ove N &egrave; qualsiasi).</li>
</ul>
<p>Si noti che il modo pi&ugrave; comune di procedere per lo sviluppo di una specifica GUI &egrave; quello di estendere la classe <code>javax.swing.</code><strong><code>JFrame</code></strong> al fine di ottenere una finestra grafica con tutte le caratteristiche desiderate.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>
<h5 id="fase-2-gui-interattiva">Fase 2: GUI interattiva</h5>
<p>Per rendere una GUI interattiva &egrave; necessario collegare le componenti swing con le quali interagisce l'utente, tramite il mouse e/o la tastiera, ad oggetti <em>ascoltatori di eventi</em> (<em>event listener object</em>) che recepiscono l'input di utente e permettono di stabilire il conseguente comportamento del programma. Nel nostro caso &egrave; necessario associare un oggetto ascoltatore al <strong><code>JButton</code></strong> specificando che ad ogni click dell'utente il testo del componente <strong><code>JLabel</code></strong> deve essere aggiornato. A tale scopo la classe <strong><code>JButton</code></strong> prevede il metodo</p>
<p><code>public void addActionListener(</code><em><code>ActionListener</code></em> <code>listner)</code></p>
<p>che prende come parametro un oggetto di tipo <em><code>ActionListener</code></em>, cio&egrave; un oggetto che implementa l'interfaccia <code>java.awt.event.</code><em><code>ActionListener</code></em>. Una classe implementa l'interfaccia <em><code>ActionListener</code></em> se implementa il seguente metodo</p>
<p><code>public void  actionPerformed(</code><strong><code>ActionEvent</code></strong> <code>e)</code></p>
<p>in cui &egrave; possibile specificare il codice da eseguire a seguito dell'input di utente; tale metodo riceve in input un oggetto di tipo <code>java.awt.event.</code><strong><code>ActionEvent</code></strong> che viene generato automaticamente ogni volta che viene registrato un input di utente (click sul pulsante) e che contiene tra l'altro informazioni inerenti al tipo di evento e al tipo di componente (di tipo controllo) che l'ha generato.</p>
<p>Molto spesso l'oggetto di tipo <em><code>ActionListener</code></em> &egrave; lo stesso che rappresenta il <strong><code>JFrame</code></strong>; in questo esercizio adotteremo tale approccio, che &egrave; sintetizzato nel diagramma di classe UML riportato di seguito.</p>
<p><img src="img/SwingApplication.umlfig.svg" alt="Event Handling in SwingApplication" /> <em>Fig 3: Strategia di gestione degli eventi in SwingApplication.</em></p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>
<h5 id="esercizio-2">Esercizio 2</h5>
<p>Modificare il codice della classe <strong><code>SwingApplication</code></strong> in modo da rendere il pulsante sensibile alla pressione di un tasto della tastiera oltre che al click del mouse. Inserire inoltre un frammento di codice che consenta di specificare il look-and-feel della GUI.</p>
<h5 id="soluzione-esercizio-2">Soluzione Esercizio 2</h5>
<p>Il metodo</p>
<p><code>public void setMnemonic(int mnemonic)</code></p>
<p>consente di specificare un carattere, cio&egrave; un tasto della tastiera, utilizzabile dall'utente in alternativa al click del mouse (<em>shortcut key</em>).</p>
<p>Il look-and-feel della GUI viene invece specificato utilizzando appositi metodi statici della classe <code>javax.swing.</code><strong><code>UIManager</code></strong>. Particolarmente utili sono i seguenti metodi:</p>
<ul>
<li><code>public static void setLookAndFeel(String className)</code> <em>// imposta il look-and-feel desiderato specificandone il nome della classe</em></li>
<li><code>public static String getCrossPlatformLookAndFeelClassName()</code> <em>// ritorna il nome della classe che rappresenta il look-and-feel indipendente dalla piattaforma</em></li>
<li><code>public static String getSystemLookAndFeelClassName()</code> <em>// ritorna il look-and-feel nativo del sistema operativo</em></li>
</ul>
<p>Il look-and-feel deve essere specificato in fase iniziale, prima della costruzione della GUI.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>
<h5 id="esercizio-3">Esercizio 3</h5>
<p>Modificare la classe <strong><code>SwingApplication</code></strong> in modo che sia presente un altro pulsante la cui pressione deve avviare l'esecuzione del metodo <code>slowMethod()</code>, riportato sotto, e successivamente incrementare un'etichetta che conta il numero di esecuzioni effettuate da tale metodo.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">slowMethod</span>(<span class="dt">int</span> sec) {
        <span class="kw">try</span> {
            Thread.<span class="fu">sleep</span>(<span class="dv">1000</span> * sec);
        }
        <span class="kw">catch</span>(InterruptedException ie) {
            ie.<span class="fu">printStackTrace</span>();
        }
    }</code></pre></div>
<p><strong>Domanda</strong>: Qual &egrave; l'effetto provocato dall'esecuzione di <code>slowMethod()</code>?</p>
<h5 id="soluzione-esercizio-3">Soluzione Esercizio 3</h5>
<p>Una possibile soluzione &egrave; riportata di seguito. Tale soluzione adotta una strategia di gestione degli eventi molto simile alla precedente, ora per&ograve; &egrave; necessario introdurre un controllo aggiuntivo per capire da quale dei due pulsanti &egrave; generato l'evento <strong><code>ActionEvent</code></strong> in <code>actionPerformed()</code>; il tipo di risposta all'evento dipende infatti da chi lo ha generato, cio&egrave; dalla sorgente dell'evento.</p>
<p><img src="img/SwingApplication2.umlfig.svg" alt="Event Handling in SwingApplication" /> <em>Fig 4: Nuova strategia di gestione degli eventi, ispirata alla precedente.</em></p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>
<p><strong>Domanda</strong>: Cosa succede premendo il pulsante che innesca l'esecuzione di <code>slowMethod()</code> e subito dopo l'altro pulsante?</p>
<p>Siccome tutto il codice di <strong><code>SwingApplication</code></strong> viene eseguito in un unico thread e, nello specifico, nell'<em>event dispatch thread</em> (il codice eseguito &egrave; incapsulato all'interno di un oggetto <em><code>Runnable</code></em> passato al metodo <code>invokeLater()</code> di <code>javax.swing.</code><strong><code>SwingUtilities</code></strong>), l'esecuzione di <code>slowMethod()</code> blocca la GUI per un periodo di tempo non accettabile. In generale, la gestione di un qualunque evento blocca la GUI per tutto il tempo richiesto all'esecuzione del task innescato dall'evento stesso. Se tale task &egrave; di durata limitata, l'utente non si accorge che la GUI non risponde, se invece il task ha una durata di diversi secondi allora l'utente percepisce un malfunzionamento della GUI. Ne consegue che gli eventi che innescano task lenti devono essere gestiti in background su thread appositi, uno per ogni evento, diversi ovviamente dall'<em>event dispatch thread</em>.</p>
<p>A tale scopo il framework JFC/Swing offre delle soluzioni per gestire situazioni di questo tipo, che non richiedono di utilizzare direttamente il multithreading, cosa che comunque &egrave; sempre fattibile, ma non consigliabile. Tali soluzioni si basano sull'impiego della classe astratta <code>javax.swing.</code><em><code>SwingWorker</code></em>, la quale presenta, tra gli altri, un metodo astratto <em><code>doInBackground()</code></em> e un metodo concreto <code>done()</code>.</p>
<p>Illustriamo di seguito un possibile modo di procedere nel caso specifico. In prima battuta, conviene introdurre un nuovo metodo privato <code>executeSlowMethodInBackground()</code> che concentra al suo interno la gestione in backgorund del task lento. Poi, all'interno di tale metodo, &egrave; necessario istanziare un oggetto di una sotto-classe (anonima) di <code>javax.swing.</code><em><code>SwingWorker</code></em>. Il codice che deve essere eseguito in background, va inserito all'interno del metodo <code>doInBackground()</code> di tale sotto-classe, metodo che deve essere obbligatoriamente presente in quanto l'omonimo metodo in <code>javax.swing.</code><em><code>SwingWorker</code></em> &egrave; dichiarato <code>abstract</code>. Mentre il codice che determina il tipo di azione da espletare (ammesso che ne esista una) non appena il task lento &egrave; terminato, va inserito all'interno del metodo <code>done()</code>; si sta pertanto sovrascrivendo il metodo (concreto) <code>done()</code> di <code>javax.swing.</code><em><code>SwingWorker</code></em>. Si osservi che il codice del metodo <code>done()</code> viene eseguito nell'<em>event dispatch thread</em>. Infine, per avviare il task in background, &egrave; necessario assicurarsi che venga invocato il metodo <code>execute()</code> sull'oggetto <em><code>SwingWorker</code></em> appena creato, ci&ograve; serve ad avviare il processo appena descritto.</p>
<p><strong>IMPORTANTE:</strong> la classe astratta <em><code>SwingWorker</code></em> &egrave; una classe tipizzata, vale a dire la sua implementazione &egrave; parametrica rispetto ad alcuni tipi generici, nelle API di Java viene infatti menzionata nel seguente modo <strong><code>SwingWorker&lt;T,V&gt;</code></strong>. Dove <strong><code>T</code></strong> &egrave; un generico tipo restituito dal metodo <code>doInBackground()</code> mentre <strong><code>V</code></strong> &egrave; un altro tipo generico utilizzato per trasmettere eventuali risultati intermedi, calcolati nel thread in background, a metodi che vengono eseguiti nell'<em>event dispatch thread</em>. Tali metodi sono finalizzati generalmente a fornire dei feedback all'utente sullo stato di avanzamento del task in background. Laddove queste necessit&agrave; non sussistono, quindi non c'&egrave; un tipo non parametrico da specificare in fase di utilizzo della classe <strong><code>SwingWorker&lt;T,V&gt;</code></strong>, si deve utilizzare in luogo di <strong><code>T</code></strong> e <strong><code>V</code></strong> la classe <strong><code>Void</code></strong> e non la keyword <strong><code>void</code></strong>. Inoltre, il metodo <code>doInBackground()</code> deve ritornare <strong><code>null</code></strong>; si tratta di una mera questione di omogeniet&agrave; sintattica.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>

<!-- [end] PANDOC OUTPUT
================================================== -->

</body>
</html>
