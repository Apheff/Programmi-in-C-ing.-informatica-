<!DOCTYPE html>
<!--<html lang="en">-->
<html lang="it">
<head>
	<!--<meta charset="utf-8">-->
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="description" content="Esercitazione di Elementi di Informatica Grafica - Dipartimento d'Ingegneria - Universit&agrave; degli Studi di Perugia">
	<meta name="author" content="Luca Grilli">
	
	<title>Esercitazione di Elementi di Informatica Grafica</title>
	<style>
		#preview-box {
			background-color: rgba(1,1,1,0.1);
			padding: 1px 10px;
			border-radius: 10px;
		}
	</style>
	<link id="linkstyle" rel="stylesheet" href="css/markdown.css">
</head>

<body>

<!-- [start] SELETTORE STILE
================================================== -->
<strong>Scegli un altro foglio di stile</strong>
<div id="preview-box">
		<select style="width:100%" id="themes">
			<option value="css/markdown.css">markdown</option>
			<option value="css/markdown-alt.css">markdown-alt</option>
			<option value="css/markdown-luca.css">markdown-luca</option>
			<option value="css/markdown1.css">markdown1</option>
			<option value="css/markdown2.css">markdown2</option>
			<option value="css/markdown3.css">markdown3</option>
			<option value="css/markdown4.css">markdown4</option>
			<option value="css/markdown5.css">markdown5</option>
			<option value="css/markdown6.css">markdown6</option>
			<option value="css/markdown7.css">markdown7</option>
			<option value="css/markdown8.css">markdown8</option>
			<option value="css/markdown9.css">markdown9</option>
			<option value="css/markdown10.css">markdown10</option>
			<option value="css/avenir-white.css">avenir-white</option>
			<option value="css/foghorn.css">foghorn</option>
			<option value="css/screen.css">screen</option>
			<option value="css/swiss.css">swiss</option>
			<option value="css/pandoc-default.css">pandoc-default</option>
			<option value="css/pandoc-bigger-font-code.css">pandoc-bigger-font-code</option>
			<option value="css/splendor.css">splendor</option>
		</select>
</div>
<script>
	var linkstyle = document.getElementById('linkstyle');
	var themes = document.getElementById('themes');
	themes.onchange = function(e) {
		linkstyle.href = themes.value;
	};
</script>
<!-- [end] SELETTORE STILE
================================================== -->

<!-- [start] PANDOC OUTPUT
================================================== -->


<h1 id="gestione-degli-stream-di-byte-in-java">Gestione degli Stream di Byte in Java</h1>
<h3 id="il-concetto-di-stream">Il concetto di Stream</h3>
<p>Gli <strong>stream</strong> (<strong>flussi</strong>) forniscono un'astrazione per l'invio e la ricezione di dati tra oggetti. Uno stream pu&ograve; essere visto come un estremo di un canale per l'invio o la ricezione di dati</p>
<ul>
<li>uno <strong>stream in uscita</strong>, <strong>output stream</strong>, &egrave; un estremo da cui possono uscire dati sul canale;</li>
<li>uno <strong>stream in ingresso</strong>, <strong>input stream</strong>, &egrave; un estremo in cui possono entrare dati dal canale;</li>
<li>in Java uno stream non pu&ograve; essere contemporaneamente di input e di output, cio&egrave; gli strem sono sempre <strong>unidirezionali</strong>;</li>
<li>i dati sul canale sono sempre letti e scritti in modo <strong>sequenziale</strong>.</li>
</ul>
<p>Per creare uno stream &egrave; necessario specificare un <strong>tipo concreto</strong> di canale di comunicazione a cui lo stream &egrave; connesso; terminali, file, socket di rete, sono esempi di canali di comunicazione concreti. Gli stream di Java forniscono un'interfaccia di uso unificata, indipendente dall'effettivo canale di comunicazione a cui lo stream &egrave; connesso</p>
<ul>
<li>esistono metodi di base per <strong>scrivere</strong> dati sul canale (<strong>output stream</strong>) indipendentemente dal tipo di canale;</li>
<li>esistono metodi di base per <strong>leggere</strong> dati dal canale (<strong>input stream</strong>) indipendentemente dal tipo di canale.</li>
</ul>
<p>In questo senso gli stream forniscono un'astrazione del processo di comunicazione. Esistono poi classi (concrete) e metodi per specifiche tipologie di stream, riferite cio&egrave; a specifici canale fisici a cui gli stream si connettono.</p>
<h3 id="stream-di-byte">Stream di Byte</h3>
<p>Uno <strong>stream di byte</strong> &egrave; uno stream elementare che permette di inviare o di ricevere su un canale un byte (8 bit) per volta o una sequenza di byte in un ordine preassegnato (cio&egrave; specificato da chi ordina la spedizione). Si osservi che nella pratica il byte &egrave; il &quot;quanto elementare&quot; di informazione, cio&egrave; indipendentemente dalla sua natura (testo, immagine, audio, video), ogni informazione che deve essere elaborata, memorizzata o trasmessa, &egrave; sempre costituita da una sequenza ordinata di byte, e in particolare, da un numero intero di byte. Tuttavia, molti tipi di informazioni sono strutturati in entit&agrave; di dimensione superiore al byte, ad esempio i contenuti testuali (file di testo) sono organizzati come sequenze di caratteri, ed ogni caratteri &egrave; rappresentato da un'opportuna sequenza di byte secondo un prestabilito schema di codifica.</p>
<p>Relativamente all'ordine dei singoli bit di un byte e agli schemi di codifica, per quanto concerne gli stream di Java valgono le seguenti: * un output stream di byte spedisce sempre i bit di ogni byte da destra verso sinistra; un input stream di byte opera coerentemente con ci&ograve;; * uno stream di byte non ha alcun controllo n&eacute; sulla codifica dei dati in bit n&eacute; sull'ordine di spedizione/ricezione dei byte.</p>
<h3 id="classi-astratte-inputstream-e-outputstream">Classi astratte <em><code>InputStream</code></em> e <em><code>OutputStream</code></em></h3>
<p>In Java le classi che definiscono gli stream di byte sono:</p>
<ul>
<li><em><code>OutputStream</code></em>: definisce i metodi di base che possono essere chiamati su ogni output stream (cio&egrave; indipendentemente dal tipo concreto di canale di comunicazione);</li>
<li><em><code>InputStream</code></em>: definisce i metodi di base che possono essere chiamati su ogni input stream.</li>
</ul>
<div class="figure">
<img src="img/InputStreamOutputStream.svg" alt="Input/Output Stream in Java" />
<p class="caption">Input/Output Stream in Java</p>
</div>
<p><em>Fig 1: Input/Output Stream in Java</em></p>
<p>Le classi <em><code>OutputStream</code></em> ed <em><code>InputStream</code></em> sono classi <strong><code>abstract</code></strong> e quindi non possono essere istanziate direttamente. Ci sono invece varie classi che ereditano da <em><code>OutputStream</code></em> e da <em><code>InputStream</code></em> che possono essere istanziate. Ognuna di esse implementa i metodi di uno stream di byte in relazione ad uno specifico canale a cui lo stream &egrave; connesso.</p>
<h3 id="un-semplice-esempio">Un semplice esempio</h3>
<p>L'oggetto <code>System.in</code> &egrave; un oggetto di tipo <em><code>InputStream</code></em> collegato per default al canale di comunicazione &quot;tastiera&quot; (standard input). Vogliamo costruire una semplice classe che legge i dati immessi da tastiera e riscrive tali dati sullo schermo; utilizzeremo i metodi di base di <em><code>InputStream</code></em> sull'oggetto <code>System.in</code>.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.io.IOException;</span>

<span class="kw">public</span> <span class="kw">class</span> SimpleInput {

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) <span class="kw">throws</span> IOException {
        <span class="dt">int</span> car;
        <span class="kw">while</span> ((car = System.<span class="fu">in</span>.<span class="fu">read</span>()) &gt;= <span class="dv">0</span>)
            System.<span class="fu">out</span>.<span class="fu">write</span>(car);
    }

} <span class="co">// end class</span></code></pre></div>
<p><strong>Domanda 1</strong>: come si pu&ograve; modificare il metodo in modo tale che legga e stampi a video 8 byte per volta?</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>
<p><strong>Domanda 2</strong>: per quale motivo il metodo <code>read()</code>, che serve a leggere dei byte, restituisce un valore <strong>int</strong>? <strong>Premessa</strong>: il tipo <strong>byte</strong> consiste di 8 bit, mentre il tipo <strong>int</strong> consiste di 32 bit, ossia 4 byte. Pertanto, il tipo <strong>int</strong> &quot;contiene&quot; il tipo <strong>byte</strong>; se <span class="math inline"><em>c</em></span> denota l'intero restituito da <code>read()</code> si pu&ograve; scrivere <span class="math inline"><em>c</em> = <em>b</em><sub>3</sub><em>b</em><sub>2</sub><em>b</em><sub>1</sub><em>b</em><sub>0</sub></span>, dove <span class="math inline"><em>b</em><sub>0</sub></span> denota il byte effettivamente letto e i byte <span class="math inline"><em>b</em><sub>3</sub></span>, <span class="math inline"><em>b</em><sub>2</sub></span> e <span class="math inline"><em>b</em><sub>1</sub></span> sono tutti nulli.</p>
<p><strong>Risposta 2</strong>: usare il tipo <strong>int</strong> permette di codificare la condizione di terminazione dello stream con la condizione <code>car == -1</code>, ovvero quando tutti i bit dei byte <span class="math inline"><em>b</em><sub>3</sub><em>b</em><sub>2</sub><em>b</em><sub>1</sub><em>b</em><sub>0</sub></span> sono pari ad 1 (codifica in complemento a 2 di -1).</p>
<h3 id="come-copiare-due-file">Come copiare due file</h3>
<p>Supponiamo di disporre di un file &quot;origine.x&quot; e di volerlo copiare in un file &quot;destinazione.x&quot;. In questo caso &egrave; necessario gestire <strong>due stream</strong>: uno stream di <strong>input</strong> (<strong>lettura</strong>) dal primo file al nostro programma, ed uno stream di <strong>output</strong> (<strong>scrittura</strong>) dal programma al secondo file. Le classi concrete che implementano tali stream sono <strong><code>FileInputStream</code></strong> e <strong><code>FileOutputStream</code></strong>.</p>
<div class="figure">
<img src="img/FileInputStreamFileOutputStream.svg" alt="FileInputStream/FileOutputStream in Java" />
<p class="caption">FileInputStream/FileOutputStream in Java</p>
</div>
<p><em>Fig 2: <code>FileInputStream</code> e <code>FileOutputStream</code> in Java</em></p>
<p><strong>Esercizio</strong>: Consultando la documentazione Java (API), provare ad implementare il programma di cui sopra. Il codice del programma di copia deve risiedere all'interno del metodo <code>main()</code> della classe <strong><code>BasicCopyBytes</code></strong>.</p>
<p><strong>Suggerimento</strong>: Utilizzare per il momento i metodi <code>read()</code> e <code>write()</code> nella loro forma pi&ugrave; semplice. Evitare inoltre di gestire le varie eccezioni che possono essere sollevate.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>
<p>Testare l'applicazione creando o rinominando un qualsiasi file, di qualsiasi formato, in &quot;origine.x&quot;. Il file deve essere posto nella stessa directory del bytecode che viene eseguito dalla JVM. Verificare che l'applicazione crea un file &quot;destinazione.x&quot; identico. Per testare l'identit&agrave; usare il comando DOS <code>fc file1 file2</code> oppure usare il comando &quot;confronta file&quot; di TextPad. Testare inoltre la velocit&agrave; di copia; in questo caso &egrave; necessario che &quot;origine.x&quot; sia un file sufficientemente grande (alcuni MB di spazio).</p>
<p><strong>Domanda 3</strong>: se la copia &egrave; lenta &egrave; possibile renderla pi&ugrave; rapida? Se s&igrave;, come? In caso affermativo, implementare una classe <strong><code>FastBasicCopyBytes</code></strong>, a partire dalla classe <strong><code>BasicCopyBytes</code></strong>, in cui le operazioni di lettura e scrittura da e su file sono rese pi&ugrave; veloci.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>
<p>Verificare come varia la velocit&agrave; al variare della dimensione del buffer.</p>
<p><strong>Domanda 4</strong>: il programma cos&igrave; com'&egrave; presenta degli svantaggi? Se s&igrave;, quali?</p>
<p><strong>Risposta 4</strong>: il primo svantaggio &egrave; che i nomi dei file sono &quot;cablati&quot; nel codice, per cambiare nome si deve modificare il codice e ricompilare ogni volta. Inoltre, sarebbe preferibile gestire le eccezioni direttamente nel corpo del metodo <code>main()</code>.</p>
<p>Provare ad implementare una versione pi&ugrave; evoluta del programma in cui:</p>
<ul>
<li>il metodo <code>main()</code> dovr&agrave; prendere in ingresso due parametri, il primo indicante il nome del file da copiare ed il secondo indicante il nome della sua copia;</li>
<li>gestire nel corpo del metodo <code>main()</code> l'eccezione di tipo <strong><code>FileNotFoundException</code></strong> e, &quot;in parte&quot;, anche quella di tipo <strong><code>IOException</code></strong>;</li>
<li>il metodo <code>main()</code> dovr&agrave; rilanciare anche un'eccezione di tipo <strong><code>IllegalArgumentException</code></strong> contenente un messaggio che spieghi come tale programma deve essere lanciato da linea di comando.</li>
</ul>
<p>Una possibile implementazione del programma <strong><code>CopyBytes</code></strong> &egrave; la seguente.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">


</code></pre></div>
<p><strong>Domanda 5</strong>: per quale motivo &egrave; necessario che il metodo <code>main()</code> rilanci eccezioni di tipo <strong><code>IOException</code></strong> se esiste un blocco <code>catch</code> in cui vengono catturate?</p>

<!-- [end] PANDOC OUTPUT
================================================== -->

</body>
</html>
